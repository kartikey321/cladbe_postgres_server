Project Overview
===============

Project Statistics:
Total Files: 10
Total Size: 42.59 KB

File Types:
  .ts: 8 files
  .json: 2 files

Detected Technologies:
  - TypeScript

Folder Structure (Tree)
=====================
Legend: ✓ = Included in output, ✗ = Excluded from output

├── package.json (683 B) ✓
├── src/
│   ├── decode.ts (4.19 KB) ✓
│   ├── encode.ts (10.46 KB) ✓
│   ├── helpers/
│   │   ├── enums.ts (8.08 KB) ✓
│   │   ├── filters.ts (2.93 KB) ✓
│   │   ├── tabledef.ts (3.20 KB) ✓
│   │   └── values.ts (6.04 KB) ✓
│   ├── index.ts (128 B) ✓
│   └── types.ts (6.55 KB) ✓
└── tsconfig.json (350 B) ✓

==============

File Name: package.json
Size: 683 B
Code:
{
  "name": "@cladbe/sql-codec",
  "version": "0.1.0",
  "description": "JSON ⇄ FlatBuffers codec for SqlRpc envelopes and payloads",
  "license": "MIT",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "sideEffects": false,
  "scripts": {
    "build": "tsc -b",
    "clean": "rimraf dist tsconfig.tsbuildinfo",
    "dev": "tsc -w -b"
  },
  "dependencies": {
    "@cladbe/sql-protocol": "^0.0.0",
    "flatbuffers": "^24.3.25"
  },
  "devDependencies": {
    "@types/node": "^20.12.12",
    "rimraf": "^6.0.1",
    "typescript": "^5.5.4"
  }
}
-------- [ Separator ] ------

File Name: src/decode.ts
Size: 4.19 KB
Code:
import { SqlRpc as sr, SqlSchema as sc } from "@cladbe/sql-protocol";
import * as flatbuffers from "flatbuffers";
import { ResponseEnvelopeJson, RpcResponseJson } from "./types.js";
import { decodeFilterValue } from "./helpers/values.js";
import { mapErrorCode } from "./helpers/enums.js";

function rowsJson(env: sr.SqlRpc.ResponseEnvelope): RpcResponseJson {
  const r = new sr.SqlRpc.RowsJson();
  const got = env.data(r);
  const n = got ? (r.rowsLength() ?? 0) : 0;
  const rows: string[] = [];
  for (let i = 0; i < n; i++) {
    const s = r.rows(i);
    if (s != null) rows.push(s);
  }
  return { type: "RowsJson", rows };
}

function rowJson(env: sr.SqlRpc.ResponseEnvelope): RpcResponseJson {
  const r = new sr.SqlRpc.RowJson();
  const got = env.data(r);
  const s = got ? r.row() ?? "" : "";
  return { type: "RowJson", row: s };
}

function boolRes(env: sr.SqlRpc.ResponseEnvelope): RpcResponseJson {
  const r = new sr.SqlRpc.BoolRes();
  const got = env.data(r);
  const v = got ? !!r.value() : false;
  return { type: "BoolRes", value: v };
}

function aggRes(env: sr.SqlRpc.ResponseEnvelope): RpcResponseJson {
  const r = new sr.SqlRpc.AggRes();
  const got = env.data(r);
  const a = got ? r.agg() : null;
  const out: NonNullable<Extract<RpcResponseJson, { type: "AggRes" }>["agg"]> = {};

  if (a) {
    const count = a.count?.() ?? 0;
    if (count) out.count = count;

    function kvToMap(
      lenFn: () => number | null | undefined,
      getFn: (i: number) => sc.SqlSchema.KeyValuePair | null | undefined
    ) {
      const m: Record<string, number> = {};
      const n = lenFn() ?? 0;
      for (let i = 0; i < n; i++) {
        const kv = getFn(i);
        if (!kv) continue;
        const k = kv.key() ?? "";
        const v = Number(kv.value?.() ?? "0");
        if (k) m[k] = v;
      }
      return m;
    }

    const sum = kvToMap(() => a.sumValuesLength?.(), (i) => a.sumValues?.(i)!);
    const avg = kvToMap(() => a.avgValuesLength?.(), (i) => a.avgValues?.(i)!);
    const min = kvToMap(() => a.minimumValuesLength?.(), (i) => a.minimumValues?.(i)!);
    const max = kvToMap(() => a.maximumValuesLength?.(), (i) => a.maximumValues?.(i)!);

    if (Object.keys(sum).length) out.sumValues = sum;
    if (Object.keys(avg).length) out.avgValues = avg;
    if (Object.keys(min).length) out.minimumValues = min;
    if (Object.keys(max).length) out.maximumValues = max;
  }

  return { type: "AggRes", agg: out };
}

function rowsWithCursor(env: sr.SqlRpc.ResponseEnvelope): RpcResponseJson {
  const r = new sr.SqlRpc.RowsWithCursor();
  const got = env.data(r);

  const rows: string[] = [];
  const nrows = got ? (r.rowsLength() ?? 0) : 0;
  for (let i = 0; i < nrows; i++) {
    const s = r.rows(i);
    if (s != null) rows.push(s);
  }

  const cursor: Record<string, unknown> = {};
  const nc = got ? (r.cursorLength() ?? 0) : 0;
  for (let i = 0; i < nc; i++) {
    const ce = r.cursor(i);
    if (!ce) continue;
    const name = ce.field() ?? "";
    const t = ce.valueType();
    const v = decodeFilterValue(t, (o) => ce.value(o));
    if (name) cursor[name] = v;
  }

  return { type: "RowsWithCursor", rows, cursor };
}

// ---- Public: parse a ResponseEnvelope buffer ----

export function parseResponseBuffer(buf: Buffer): ResponseEnvelopeJson {
  const bb = new flatbuffers.ByteBuffer(
    new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)
  );
  const env = sr.SqlRpc.ResponseEnvelope.getRootAsResponseEnvelope(bb);

  const ok = !!env.ok();
  const corr = env.correlationId() ?? "";
  const code = mapErrorCode(env.errorCode());

  if (!ok) {
    return {
      correlationId: corr,
      ok,
      errorCode: code,
      errorMessage: env.errorMessage()
    };
  }

  const t = env.dataType();
  let data: RpcResponseJson | undefined;

  switch (t) {
    case sr.SqlRpc.RpcResponse.RowsJson: data = rowsJson(env); break;
    case sr.SqlRpc.RpcResponse.RowJson: data = rowJson(env); break;
    case sr.SqlRpc.RpcResponse.BoolRes: data = boolRes(env); break;
    case sr.SqlRpc.RpcResponse.AggRes: data = aggRes(env); break;
    case sr.SqlRpc.RpcResponse.RowsWithCursor: data = rowsWithCursor(env); break;
    default: data = undefined; break;
  }

  return {
    correlationId: corr,
    ok,
    errorCode: code,
    data
  };
}
-------- [ Separator ] ------

File Name: src/encode.ts
Size: 10.46 KB
Code:
import * as flatbuffers from "flatbuffers";
import { SqlRpc as sr, SqlSchema as sc } from "@cladbe/sql-protocol";
import {
  RequestEnvelopeJson,
  GetDataJson,
  GetSingleJson,
  AddSingleJson,
  UpdateSingleJson,
  DeleteRowJson,
  CreateTableJson,
  TableExistsJson,
  RunAggregationJson,
  OrderKeySpec,
  SqlDataFilterWrapper,
  BaseSqlDataFilter
} from "./types.js";
import { encodeFilterValue } from "./helpers/values.js";
import { encodeWrapper, isWrapper } from "./helpers/filters.js";
import { encodeTableDefinition } from "./helpers/tabledef.js";
import { mapOrderSort } from "./helpers/enums.js";

// ---- Field/vector helpers ----

function encodeOrder(b: flatbuffers.Builder, order?: OrderKeySpec[]): number {
  if (!order?.length) return 0;
  const offsets: number[] = [];
  for (const o of order) {
    const field = b.createString(o.field);
    sc.SqlSchema.OrderKeySpec.startOrderKeySpec(b);
    sc.SqlSchema.OrderKeySpec.addField(b, field);
    sc.SqlSchema.OrderKeySpec.addSort(b, mapOrderSort(o.sort));
    const off = sc.SqlSchema.OrderKeySpec.endOrderKeySpec(b);
    offsets.push(off);
  }
  // Vector must be created by the owning table helper
  return sr.SqlRpc.GetDataReq.createOrderVector(b, offsets);
}

function encodeCursor(b: flatbuffers.Builder, cursor?: Record<string, unknown>): number {
  if (!cursor) return 0;
  const entries: number[] = [];
  for (const [field, val] of Object.entries(cursor)) {
    const f = b.createString(field);
    const { type, off } = encodeFilterValue(b, val);
    sc.SqlSchema.CursorEntry.startCursorEntry(b);
    sc.SqlSchema.CursorEntry.addField(b, f);
    sc.SqlSchema.CursorEntry.addValueType(b, type);
    sc.SqlSchema.CursorEntry.addValue(b, off);
    const e = sc.SqlSchema.CursorEntry.endCursorEntry(b);
    entries.push(e);
  }
  // Vector must be created by the owning table helper
  return sr.SqlRpc.GetDataReq.createCursorVector(b, entries);
}


function encodeWrapperMaybe(
  b: flatbuffers.Builder,
  filters?: SqlDataFilterWrapper | BaseSqlDataFilter[] | BaseSqlDataFilter
): number {
  if (!filters) return 0;

  // Accept either a single wrapper or the common [wrapper] shape.
  const candidate = Array.isArray(filters) ? (filters[0] as BaseSqlDataFilter | undefined) : filters;
  if (!candidate) return 0;

  if (!isWrapper(candidate)) {
    throw new Error("filters must be a SqlDataFilterWrapper or [SqlDataFilterWrapper]");
  }
  return encodeWrapper(b, candidate);
}

// ---- Request encoders ----

function encodeGetData(b: flatbuffers.Builder, j: GetDataJson): number {
  const company = b.createString(j.companyId);
  const table = b.createString(j.tableName);
  const wrapperOff = encodeWrapperMaybe(b, j.filters);
  const orderVec = encodeOrder(b, j.orderKeys);
  const cursorVec = encodeCursor(b, j.cursor);

  sr.SqlRpc.GetDataReq.startGetDataReq(b);
  sr.SqlRpc.GetDataReq.addCompanyId(b, company);
  sr.SqlRpc.GetDataReq.addTableName(b, table);
  if (wrapperOff) sr.SqlRpc.GetDataReq.addWrapper(b, wrapperOff);
  if (j.limit !== undefined) sr.SqlRpc.GetDataReq.addLimit(b, j.limit >>> 0);
  if (j.offset !== undefined) sr.SqlRpc.GetDataReq.addOffset(b, j.offset >>> 0);
  if (orderVec) sr.SqlRpc.GetDataReq.addOrder(b, orderVec);
  if (cursorVec) sr.SqlRpc.GetDataReq.addCursor(b, cursorVec);
  sr.SqlRpc.GetDataReq.addStrictAfter(b, j.strictAfter ?? true);
  return sr.SqlRpc.GetDataReq.endGetDataReq(b);
}

function encodeRunAggregation(b: flatbuffers.Builder, j: RunAggregationJson): number {
  const company = b.createString(j.companyId);
  const table = b.createString(j.tableName);

  const sumVec = j.sumFields?.length
    ? sr.SqlRpc.RunAggregationReq.createSumFieldsVector(b, j.sumFields.map((s) => b.createString(s)))
    : 0;
  const avgVec = j.averageFields?.length
    ? sr.SqlRpc.RunAggregationReq.createAverageFieldsVector(b, j.averageFields.map((s) => b.createString(s)))
    : 0;
  const minVec = j.minimumFields?.length
    ? sr.SqlRpc.RunAggregationReq.createMinimumFieldsVector(b, j.minimumFields.map((s) => b.createString(s)))
    : 0;
  const maxVec = j.maximumFields?.length
    ? sr.SqlRpc.RunAggregationReq.createMaximumFieldsVector(b, j.maximumFields.map((s) => b.createString(s)))
    : 0;

  const wrapperOff = encodeWrapperMaybe(b, j.filters);

  sr.SqlRpc.RunAggregationReq.startRunAggregationReq(b);
  sr.SqlRpc.RunAggregationReq.addCompanyId(b, company);
  sr.SqlRpc.RunAggregationReq.addTableName(b, table);
  sr.SqlRpc.RunAggregationReq.addCountEnabled(b, !!j.countEnabled);
  if (sumVec) sr.SqlRpc.RunAggregationReq.addSumFields(b, sumVec);
  if (avgVec) sr.SqlRpc.RunAggregationReq.addAverageFields(b, avgVec);
  if (minVec) sr.SqlRpc.RunAggregationReq.addMinimumFields(b, minVec);
  if (maxVec) sr.SqlRpc.RunAggregationReq.addMaximumFields(b, maxVec);
  if (wrapperOff) sr.SqlRpc.RunAggregationReq.addWrapper(b, wrapperOff);
  return sr.SqlRpc.RunAggregationReq.endRunAggregationReq(b);
}

function encodeGetSingle(b: flatbuffers.Builder, j: GetSingleJson): number {
  const company = b.createString(j.companyId);
  const table = b.createString(j.tableName);
  const pkc = b.createString(j.primaryKeyColumn);
  const pk = b.createString(j.primaryId);

  sr.SqlRpc.GetSingleReq.startGetSingleReq(b);
  sr.SqlRpc.GetSingleReq.addCompanyId(b, company);
  sr.SqlRpc.GetSingleReq.addTableName(b, table);
  sr.SqlRpc.GetSingleReq.addPrimaryKeyColumn(b, pkc);
  sr.SqlRpc.GetSingleReq.addPrimaryId(b, pk);
  return sr.SqlRpc.GetSingleReq.endGetSingleReq(b);
}

function encodeAddSingle(b: flatbuffers.Builder, j: AddSingleJson): number {
  const company = b.createString(j.companyId);
  const table = b.createString(j.tableName);
  const pkc = b.createString(j.primaryKeyColumn);
  const row = b.createString(JSON.stringify(j.data ?? {}));

  sr.SqlRpc.AddSingleReq.startAddSingleReq(b);
  sr.SqlRpc.AddSingleReq.addCompanyId(b, company);
  sr.SqlRpc.AddSingleReq.addTableName(b, table);
  sr.SqlRpc.AddSingleReq.addPrimaryKeyColumn(b, pkc);
  sr.SqlRpc.AddSingleReq.addRowJson(b, row);
  return sr.SqlRpc.AddSingleReq.endAddSingleReq(b);
}

function encodeUpdateSingle(b: flatbuffers.Builder, j: UpdateSingleJson): number {
  const company = b.createString(j.companyId);
  const table = b.createString(j.tableName);
  const pkc = b.createString(j.primaryKeyColumn);
  const pk = b.createString(j.primaryId);
  const upd = b.createString(JSON.stringify(j.updates ?? {}));

  sr.SqlRpc.UpdateSingleReq.startUpdateSingleReq(b);
  sr.SqlRpc.UpdateSingleReq.addCompanyId(b, company);
  sr.SqlRpc.UpdateSingleReq.addTableName(b, table);
  sr.SqlRpc.UpdateSingleReq.addPrimaryKeyColumn(b, pkc);
  sr.SqlRpc.UpdateSingleReq.addPrimaryId(b, pk);
  sr.SqlRpc.UpdateSingleReq.addUpdatesJson(b, upd);
  return sr.SqlRpc.UpdateSingleReq.endUpdateSingleReq(b);
}

function encodeDeleteRow(b: flatbuffers.Builder, j: DeleteRowJson): number {
  const company = b.createString(j.companyId);
  const table = b.createString(j.tableName);
  const pkc = b.createString(j.primaryKeyColumn);
  const pk = b.createString(j.primaryId);

  sr.SqlRpc.DeleteRowReq.startDeleteRowReq(b);
  sr.SqlRpc.DeleteRowReq.addCompanyId(b, company);
  sr.SqlRpc.DeleteRowReq.addTableName(b, table);
  sr.SqlRpc.DeleteRowReq.addPrimaryKeyColumn(b, pkc);
  sr.SqlRpc.DeleteRowReq.addPrimaryId(b, pk);
  return sr.SqlRpc.DeleteRowReq.endDeleteRowReq(b);
}

function encodeCreateTable(b: flatbuffers.Builder, j: CreateTableJson): number {
  const company = b.createString(j.companyId);
  const defOff = encodeTableDefinition(b, j.definition);

  sr.SqlRpc.CreateTableReq.startCreateTableReq(b);
  sr.SqlRpc.CreateTableReq.addCompanyId(b, company);
  sr.SqlRpc.CreateTableReq.addDefinition(b, defOff);
  return sr.SqlRpc.CreateTableReq.endCreateTableReq(b);
}

function encodeTableExists(b: flatbuffers.Builder, j: TableExistsJson): number {
  const company = b.createString(j.companyId);
  const table = b.createString(j.tableName);

  sr.SqlRpc.TableExistsReq.startTableExistsReq(b);
  sr.SqlRpc.TableExistsReq.addCompanyId(b, company);
  sr.SqlRpc.TableExistsReq.addTableName(b, table);
  return sr.SqlRpc.TableExistsReq.endTableExistsReq(b);
}



// ---- Payload union builder ----

function asUnion(type: number, off: number) {
  return { type, off };
}

function encodePayload(b: flatbuffers.Builder, req: RequestEnvelopeJson): { type: number; off: number } {
  switch (req.method) {
    case "GET_DATA":        return asUnion(sr.SqlRpc.RpcPayload.GetDataReq,        encodeGetData(b, req.payload));
    case "GET_SINGLE":      return asUnion(sr.SqlRpc.RpcPayload.GetSingleReq,      encodeGetSingle(b, req.payload));
    case "ADD_SINGLE":      return asUnion(sr.SqlRpc.RpcPayload.AddSingleReq,      encodeAddSingle(b, req.payload));
    case "UPDATE_SINGLE":   return asUnion(sr.SqlRpc.RpcPayload.UpdateSingleReq,   encodeUpdateSingle(b, req.payload));
    case "DELETE_ROW":      return asUnion(sr.SqlRpc.RpcPayload.DeleteRowReq,      encodeDeleteRow(b, req.payload));
    case "CREATE_TABLE":    return asUnion(sr.SqlRpc.RpcPayload.CreateTableReq,    encodeCreateTable(b, req.payload));
    case "TABLE_EXISTS":    return asUnion(sr.SqlRpc.RpcPayload.TableExistsReq,    encodeTableExists(b, req.payload));
    case "RUN_AGGREGATION": return asUnion(sr.SqlRpc.RpcPayload.RunAggregationReq, encodeRunAggregation(b, req.payload));
  }
}

// ---- Public: build a RequestEnvelope buffer ----

export function buildRequestBuffer(req: RequestEnvelopeJson): Buffer {
  const b = new flatbuffers.Builder(2048);

  const corr = b.createString(req.correlationId);
  const reply = b.createString(req.replyTopic);
  const { type, off } = encodePayload(b, req);

  sr.SqlRpc.RequestEnvelope.startRequestEnvelope(b);
  sr.SqlRpc.RequestEnvelope.addCorrelationId(b, corr);
  sr.SqlRpc.RequestEnvelope.addReplyTopic(b, reply);

  const methodNum = (() => {
    switch (req.method) {
      case "GET_DATA": return sr.SqlRpc.RpcMethod.GET_DATA;
      case "GET_SINGLE": return sr.SqlRpc.RpcMethod.GET_SINGLE;
      case "ADD_SINGLE": return sr.SqlRpc.RpcMethod.ADD_SINGLE;
      case "UPDATE_SINGLE": return sr.SqlRpc.RpcMethod.UPDATE_SINGLE;
      case "DELETE_ROW": return sr.SqlRpc.RpcMethod.DELETE_ROW;
      case "CREATE_TABLE": return sr.SqlRpc.RpcMethod.CREATE_TABLE;
      case "TABLE_EXISTS": return sr.SqlRpc.RpcMethod.TABLE_EXISTS;
      case "RUN_AGGREGATION": return sr.SqlRpc.RpcMethod.RUN_AGGREGATION;
    }
  })()!; // exhaustive due to union type

  sr.SqlRpc.RequestEnvelope.addMethod(b, methodNum);
  sr.SqlRpc.RequestEnvelope.addPayloadType(b, type);
  sr.SqlRpc.RequestEnvelope.addPayload(b, off);
  const env = sr.SqlRpc.RequestEnvelope.endRequestEnvelope(b);
  b.finish(env);
  return Buffer.from(b.asUint8Array());
}
-------- [ Separator ] ------

File Name: src/helpers/enums.ts
Size: 8.08 KB
Code:
import { SqlSchema as sc, SqlRpc as sr } from "@cladbe/sql-protocol";
import {
  ColumnConstraint,
  NullsSortOrder,
  OrderSort,
  SQLDataFilterType,
  SQLFilterWrapperType,
  SQLDataType
} from "../types.js";

// ---- JSON → FB enum mappers ----

export function mapOrderSort(v: OrderSort): sc.SqlSchema.OrderSort {
  switch (v) {
    case OrderSort.ASC_DEFAULT: return sc.SqlSchema.OrderSort.ASC_DEFAULT;
    case OrderSort.ASC_NULLS_FIRST: return sc.SqlSchema.OrderSort.ASC_NULLS_FIRST;
    case OrderSort.ASC_NULLS_LAST: return sc.SqlSchema.OrderSort.ASC_NULLS_LAST;
    case OrderSort.DESC_DEFAULT: return sc.SqlSchema.OrderSort.DESC_DEFAULT;
    case OrderSort.DESC_NULLS_FIRST: return sc.SqlSchema.OrderSort.DESC_NULLS_FIRST;
    case OrderSort.DESC_NULLS_LAST: return sc.SqlSchema.OrderSort.DESC_NULLS_LAST;
  }
}

export function mapWrapperType(v: SQLFilterWrapperType): sc.SqlSchema.SQLFilterWrapperType {
  return v === SQLFilterWrapperType.and
    ? sc.SqlSchema.SQLFilterWrapperType.and
    : sc.SqlSchema.SQLFilterWrapperType.or;
}

export function mapNullsSortOrder(v: NullsSortOrder): sc.SqlSchema.NullsSortOrder {
  switch (v) {
    case NullsSortOrder.first: return sc.SqlSchema.NullsSortOrder.first;
    case NullsSortOrder.last: return sc.SqlSchema.NullsSortOrder.last;
    default: return sc.SqlSchema.NullsSortOrder.default_;
  }
}

export function mapFilterType(v: SQLDataFilterType): sc.SqlSchema.BasicSqlDataFilterType {
  // Only map those that exist in BasicSqlDataFilterType
  switch (v) {
    case "equals": return sc.SqlSchema.BasicSqlDataFilterType.equals;
    case "notEquals": return sc.SqlSchema.BasicSqlDataFilterType.notEquals;
    case "lessThan": return sc.SqlSchema.BasicSqlDataFilterType.lessThan;
    case "lessThanOrEquals": return sc.SqlSchema.BasicSqlDataFilterType.lessThanOrEquals;
    case "greaterThan": return sc.SqlSchema.BasicSqlDataFilterType.greaterThan;
    case "greaterThanOrEquals": return sc.SqlSchema.BasicSqlDataFilterType.greaterThanOrEquals;

    case "isNull": return sc.SqlSchema.BasicSqlDataFilterType.isNull;
    case "isNotNull": return sc.SqlSchema.BasicSqlDataFilterType.isNotNull;

    case "regex": return sc.SqlSchema.BasicSqlDataFilterType.regex;
    case "notRegex": return sc.SqlSchema.BasicSqlDataFilterType.notRegex;
    case "startsWith": return sc.SqlSchema.BasicSqlDataFilterType.startsWith;
    case "endsWith": return sc.SqlSchema.BasicSqlDataFilterType.endsWith;
    case "contains": return sc.SqlSchema.BasicSqlDataFilterType.contains;
    case "notContains": return sc.SqlSchema.BasicSqlDataFilterType.notContains;

    case "arrayContains": return sc.SqlSchema.BasicSqlDataFilterType.arrayContains;
    case "arrayContainedBy": return sc.SqlSchema.BasicSqlDataFilterType.arrayContainedBy;
    case "arrayOverlaps": return sc.SqlSchema.BasicSqlDataFilterType.arrayOverlaps;
    case "arrayEquals": return sc.SqlSchema.BasicSqlDataFilterType.arrayEquals;
    case "arrayNotEquals": return sc.SqlSchema.BasicSqlDataFilterType.arrayNotEquals;
    case "arrayEmpty": return sc.SqlSchema.BasicSqlDataFilterType.arrayEmpty;
    case "arrayNotEmpty": return sc.SqlSchema.BasicSqlDataFilterType.arrayNotEmpty;
    case "arrayLength": return sc.SqlSchema.BasicSqlDataFilterType.arrayLength;

    case "jsonContains": return sc.SqlSchema.BasicSqlDataFilterType.jsonContains;
    case "jsonContainedBy": return sc.SqlSchema.BasicSqlDataFilterType.jsonContainedBy;
    case "jsonHasKey": return sc.SqlSchema.BasicSqlDataFilterType.jsonHasKey;
    case "jsonHasAnyKey": return sc.SqlSchema.BasicSqlDataFilterType.jsonHasAnyKey;
    case "jsonHasAllKeys": return sc.SqlSchema.BasicSqlDataFilterType.jsonHasAllKeys;
    case "jsonGetField": return sc.SqlSchema.BasicSqlDataFilterType.jsonGetField;
    case "jsonGetFieldAsText": return sc.SqlSchema.BasicSqlDataFilterType.jsonGetFieldAsText;

    case "between": return sc.SqlSchema.BasicSqlDataFilterType.between;
    case "notBetween": return sc.SqlSchema.BasicSqlDataFilterType.notBetween;
    case "rangeContains": return sc.SqlSchema.BasicSqlDataFilterType.rangeContains;
    case "rangeContainedBy": return sc.SqlSchema.BasicSqlDataFilterType.rangeContainedBy;

    case "in": return sc.SqlSchema.BasicSqlDataFilterType.inList;
    case "notIn": return sc.SqlSchema.BasicSqlDataFilterType.notInList;

    default:
      throw new Error(`Unsupported filterType for FlatBuffers: ${v}`);
  }
}

export function mapSqlType(v: SQLDataType): sc.SqlSchema.SQLDataType {
  switch (v) {
    case SQLDataType.text: return sc.SqlSchema.SQLDataType.text;
    case SQLDataType.varchar: return sc.SqlSchema.SQLDataType.varchar;
    case SQLDataType.char: return sc.SqlSchema.SQLDataType.char_;
    case SQLDataType.varcharArray: return sc.SqlSchema.SQLDataType.varcharArray;
    case SQLDataType.textArray: return sc.SqlSchema.SQLDataType.textArray;
    case SQLDataType.charArray: return sc.SqlSchema.SQLDataType.charArray;
    case SQLDataType.integer: return sc.SqlSchema.SQLDataType.integer;
    case SQLDataType.bigInt: return sc.SqlSchema.SQLDataType.bigInt;
    case SQLDataType.smallInt: return sc.SqlSchema.SQLDataType.smallInt;
    case SQLDataType.decimal: return sc.SqlSchema.SQLDataType.decimal;
    case SQLDataType.numeric: return sc.SqlSchema.SQLDataType.numeric;
    case SQLDataType.real: return sc.SqlSchema.SQLDataType.real;
    case SQLDataType.doublePrecision: return sc.SqlSchema.SQLDataType.doublePrecision;
    case SQLDataType.serial: return sc.SqlSchema.SQLDataType.serial;
    case SQLDataType.bigSerial: return sc.SqlSchema.SQLDataType.bigSerial;
    case SQLDataType.smallSerial: return sc.SqlSchema.SQLDataType.smallSerial;
    case SQLDataType.money: return sc.SqlSchema.SQLDataType.money;
    case SQLDataType.date: return sc.SqlSchema.SQLDataType.date;
    case SQLDataType.time: return sc.SqlSchema.SQLDataType.time;
    case SQLDataType.timestamp: return sc.SqlSchema.SQLDataType.timestamp;
    case SQLDataType.timestamptz: return sc.SqlSchema.SQLDataType.timestamptz;
    case SQLDataType.interval: return sc.SqlSchema.SQLDataType.interval;
    case SQLDataType.timetz: return sc.SqlSchema.SQLDataType.timetz;
    case SQLDataType.boolean: return sc.SqlSchema.SQLDataType.boolean_;
    case SQLDataType.bytea: return sc.SqlSchema.SQLDataType.bytea;
    case SQLDataType.json: return sc.SqlSchema.SQLDataType.json;
    case SQLDataType.jsonb: return sc.SqlSchema.SQLDataType.jsonb;
    case SQLDataType.jsonArray: return sc.SqlSchema.SQLDataType.jsonArray;
    case SQLDataType.jsonbArray: return sc.SqlSchema.SQLDataType.jsonbArray;
    case SQLDataType.uuid: return sc.SqlSchema.SQLDataType.uuid;
    case SQLDataType.xml: return sc.SqlSchema.SQLDataType.xml;
    case SQLDataType.array: return sc.SqlSchema.SQLDataType.array;
    case SQLDataType.custom: return sc.SqlSchema.SQLDataType.custom;
  }
}

export function mapConstraint(v: ColumnConstraint): sc.SqlSchema.ColumnConstraint {
  switch (v) {
    case ColumnConstraint.primaryKey: return sc.SqlSchema.ColumnConstraint.primaryKey;
    case ColumnConstraint.unique: return sc.SqlSchema.ColumnConstraint.unique;
    case ColumnConstraint.notNull: return sc.SqlSchema.ColumnConstraint.notNull;
    case ColumnConstraint.check: return sc.SqlSchema.ColumnConstraint.check;
    case ColumnConstraint.default_: return sc.SqlSchema.ColumnConstraint.default_;
    case ColumnConstraint.indexed: return sc.SqlSchema.ColumnConstraint.indexed;
    case ColumnConstraint.exclusion: return sc.SqlSchema.ColumnConstraint.exclusion;
    case ColumnConstraint.generated: return sc.SqlSchema.ColumnConstraint.generated;
    case ColumnConstraint.identity: return sc.SqlSchema.ColumnConstraint.identity;
    case ColumnConstraint.references: return sc.SqlSchema.ColumnConstraint.references;
    case ColumnConstraint.noInherit: return sc.SqlSchema.ColumnConstraint.noInherit;
    case ColumnConstraint.nullsNotDistinct: return sc.SqlSchema.ColumnConstraint.nullsNotDistinct;
  }
}

// ---- FB → JSON error enum ----
export function mapErrorCode(code: sr.SqlRpc.ErrorCode): "NONE" | "BAD_REQUEST" | "INTERNAL" {
  switch (code) {
    case sr.SqlRpc.ErrorCode.NONE: return "NONE";
    case sr.SqlRpc.ErrorCode.BAD_REQUEST: return "BAD_REQUEST";
    default: return "INTERNAL";
  }
}
-------- [ Separator ] ------

File Name: src/helpers/filters.ts
Size: 2.93 KB
Code:
import * as flatbuffers from "flatbuffers";
import { SqlSchema as sc } from "@cladbe/sql-protocol";
import {
  BaseSqlDataFilter,
  SqlDataFilter,
  SqlDataFilterWrapper,
  SqlFilterModifier
} from "../types.js";
import { encodeFilterValue } from "./values.js";
import { mapFilterType, mapNullsSortOrder, mapWrapperType } from "./enums.js";

// Type guards
export function isWrapper(f: BaseSqlDataFilter): f is SqlDataFilterWrapper {
  return (f as SqlDataFilterWrapper).filters !== undefined;
}
function isSingle(f: BaseSqlDataFilter): f is SqlDataFilter {
  return (f as SqlDataFilter).fieldName !== undefined;
}

function encodeModifier(b: flatbuffers.Builder, m?: SqlFilterModifier): number {
  if (!m) return 0;
  sc.SqlSchema.SqlFilterModifier.startSqlFilterModifier(b);
  sc.SqlSchema.SqlFilterModifier.addDistinct(b, !!m.distinct);
  sc.SqlSchema.SqlFilterModifier.addCaseInsensitive(b, !!m.caseInSensitive);
  sc.SqlSchema.SqlFilterModifier.addNullsOrder(b, mapNullsSortOrder(m.nullsOrder));
  return sc.SqlSchema.SqlFilterModifier.endSqlFilterModifier(b);
}

function encodeSingleFilter(b: flatbuffers.Builder, f: SqlDataFilter): number {
  const field = b.createString(f.fieldName);
  const { type, off } = encodeFilterValue(b, f.value);
  const modOff = encodeModifier(b, f.modifier);
  sc.SqlSchema.BasicSqlDataFilter.startBasicSqlDataFilter(b);
  sc.SqlSchema.BasicSqlDataFilter.addFieldName(b, field);
  sc.SqlSchema.BasicSqlDataFilter.addValueType(b, type);
  sc.SqlSchema.BasicSqlDataFilter.addValue(b, off);
  sc.SqlSchema.BasicSqlDataFilter.addFilterType(b, mapFilterType(f.filterType));
  if (modOff) sc.SqlSchema.BasicSqlDataFilter.addModifier(b, modOff);
  return sc.SqlSchema.BasicSqlDataFilter.endBasicSqlDataFilter(b);
}

export function encodeWrapper(b: flatbuffers.Builder, w: SqlDataFilterWrapper): number {
  const filterOffsets: number[] = [];

  for (const node of w.filters) {
    if (isWrapper(node)) {
      const wrapOff = encodeWrapper(b, node);
      filterOffsets.push(wrapOff);
    } else if (isSingle(node)) {
      const sfOff = encodeSingleFilter(b, node);
      filterOffsets.push(sfOff);
    } else {
      throw new Error("Unknown filter node");
    }
  }

  const types: number[] = w.filters.map((node) =>
    isWrapper(node)
      ? sc.SqlSchema.BasicSqlDataFilterUnion.BasicSqlDataFilterWrapper
      : sc.SqlSchema.BasicSqlDataFilterUnion.BasicSqlDataFilter
  );

  const typesVec = sc.SqlSchema.BasicSqlDataFilterWrapper.createFiltersTypeVector(b, types);
  const filtersVec = sc.SqlSchema.BasicSqlDataFilterWrapper.createFiltersVector(b, filterOffsets);

  sc.SqlSchema.BasicSqlDataFilterWrapper.startBasicSqlDataFilterWrapper(b);
  sc.SqlSchema.BasicSqlDataFilterWrapper.addFilterWrapperType(b, mapWrapperType(w.filterWrapperType));
  sc.SqlSchema.BasicSqlDataFilterWrapper.addFiltersType(b, typesVec);
  sc.SqlSchema.BasicSqlDataFilterWrapper.addFilters(b, filtersVec);
  return sc.SqlSchema.BasicSqlDataFilterWrapper.endBasicSqlDataFilterWrapper(b);
}
-------- [ Separator ] ------

File Name: src/helpers/tabledef.ts
Size: 3.20 KB
Code:
import * as flatbuffers from "flatbuffers";
import { SqlSchema as sc } from "@cladbe/sql-protocol";
import {
  TableDefinitionJson,
  TableColumnJson
} from "../types.js";
import { mapConstraint, mapSqlType } from "./enums.js";

function encodeKeyValueVec(
  b: flatbuffers.Builder,
  obj?: Record<string, string | number | boolean>
): number {
  if (!obj || !Object.keys(obj).length) return 0;
  const entries: number[] = [];
  for (const [k, v] of Object.entries(obj)) {
    const ko = b.createString(k);
    const vo = b.createString(String(v));
    sc.SqlSchema.KeyValuePair.startKeyValuePair(b);
    sc.SqlSchema.KeyValuePair.addKey(b, ko);
    sc.SqlSchema.KeyValuePair.addValue(b, vo);
    const off = sc.SqlSchema.KeyValuePair.endKeyValuePair(b);
    entries.push(off);
  }
  const vec = sc.SqlSchema.CustomOptions.createOptionsVector(b, entries);
  sc.SqlSchema.CustomOptions.startCustomOptions(b);
  sc.SqlSchema.CustomOptions.addOptions(b, vec);
  return sc.SqlSchema.CustomOptions.endCustomOptions(b);
}

function encodeTableOptions(
  b: flatbuffers.Builder,
  obj?: Record<string, string | number | boolean>
): number {
  if (!obj || !Object.keys(obj).length) return 0;
  const entries: number[] = [];
  for (const [k, v] of Object.entries(obj)) {
    const ko = b.createString(k);
    const vo = b.createString(String(v));
    sc.SqlSchema.KeyValuePair.startKeyValuePair(b);
    sc.SqlSchema.KeyValuePair.addKey(b, ko);
    sc.SqlSchema.KeyValuePair.addValue(b, vo);
    const off = sc.SqlSchema.KeyValuePair.endKeyValuePair(b);
    entries.push(off);
  }
  const vec = sc.SqlSchema.TableOptions.createOptionsVector(b, entries);
  sc.SqlSchema.TableOptions.startTableOptions(b);
  sc.SqlSchema.TableOptions.addOptions(b, vec);
  return sc.SqlSchema.TableOptions.endTableOptions(b);
}

function encodeColumn(b: flatbuffers.Builder, c: TableColumnJson): number {
  const name = b.createString(c.name);
  const cons = c.constraints.map(mapConstraint);
  const consVec = sc.SqlSchema.TableColumn.createConstraintsVector(b, cons);
  const customOff = encodeKeyValueVec(b, c.customOptions);

  sc.SqlSchema.TableColumn.startTableColumn(b);
  sc.SqlSchema.TableColumn.addName(b, name);
  sc.SqlSchema.TableColumn.addDataType(b, mapSqlType(c.dataType));
  sc.SqlSchema.TableColumn.addIsNullable(b, !!c.isNullable);
  sc.SqlSchema.TableColumn.addConstraints(b, consVec);
  if (customOff) sc.SqlSchema.TableColumn.addCustomOptions(b, customOff);
  return sc.SqlSchema.TableColumn.endTableColumn(b);
}

export function encodeTableDefinition(b: flatbuffers.Builder, td: TableDefinitionJson): number {
  const name = b.createString(td.name);
  const cols = td.columns.map((c) => encodeColumn(b, c));
  const colsVec = sc.SqlSchema.TableDefinition.createColumnsVector(b, cols);
  const commentOff = td.comment ? b.createString(td.comment) : 0;
  const optsOff = encodeTableOptions(b, td.tableOptions);

  sc.SqlSchema.TableDefinition.startTableDefinition(b);
  sc.SqlSchema.TableDefinition.addName(b, name);
  sc.SqlSchema.TableDefinition.addColumns(b, colsVec);
  if (commentOff) sc.SqlSchema.TableDefinition.addComment(b, commentOff);
  if (optsOff) sc.SqlSchema.TableDefinition.addTableOptions(b, optsOff);
  return sc.SqlSchema.TableDefinition.endTableDefinition(b);
}
-------- [ Separator ] ------

File Name: src/helpers/values.ts
Size: 6.04 KB
Code:
import { SqlSchema as sc } from "@cladbe/sql-protocol";
import * as flatbuffers from "flatbuffers";

// Decide list type: prefer StringList if strings, Int64List if ints safe, Float64List if numbers
function isInteger(n: number): boolean {
  return Number.isInteger(n);
}

function isStringArray(a: unknown[]): a is string[] {
  return a.every((x) => typeof x === "string");
}
function isBoolArray(a: unknown[]): a is boolean[] {
  return a.every((x) => typeof x === "boolean");
}
function isNumberArray(a: unknown[]): a is number[] {
  return a.every((x) => typeof x === "number" && Number.isFinite(x));
}

/** JSON value -> (FilterValue.type, offset) */
export function encodeFilterValue(b: flatbuffers.Builder, v: unknown): { type: number; off: number } {
  // null
  if (v === null || v === undefined) {
    sc.SqlSchema.NullValue.startNullValue(b);
    const off = sc.SqlSchema.NullValue.endNullValue(b);
    return { type: sc.SqlSchema.FilterValue.NullValue, off };
  }

  // scalar
  if (typeof v === "string") {
    const s = b.createString(v);
    sc.SqlSchema.StringValue.startStringValue(b);
    sc.SqlSchema.StringValue.addValue(b, s);
    const off = sc.SqlSchema.StringValue.endStringValue(b);
    return { type: sc.SqlSchema.FilterValue.StringValue, off };
  }
  if (typeof v === "boolean") {
    sc.SqlSchema.BoolValue.startBoolValue(b);
    sc.SqlSchema.BoolValue.addValue(b, v);
    const off = sc.SqlSchema.BoolValue.endBoolValue(b);
    return { type: sc.SqlSchema.FilterValue.BoolValue, off };
  }
  if (typeof v === "number") {
    // Use NumberValue (double) to avoid JS int64 issues
    sc.SqlSchema.NumberValue.startNumberValue(b);
    sc.SqlSchema.NumberValue.addValue(b, v);
    const off = sc.SqlSchema.NumberValue.endNumberValue(b);
    return { type: sc.SqlSchema.FilterValue.NumberValue, off };
  }

  // array
  if (Array.isArray(v)) {
    if (v.length === 0) {
      // empty → encode as StringList empty (choice is arbitrary but consistent)
      const vec = sc.SqlSchema.StringList.createValuesVector(b, []);
      sc.SqlSchema.StringList.startStringList(b);
      sc.SqlSchema.StringList.addValues(b, vec);
      const off = sc.SqlSchema.StringList.endStringList(b);
      return { type: sc.SqlSchema.FilterValue.StringList, off };
    }
    if (isStringArray(v)) {
      const offs = v.map((s) => b.createString(s));
      const vec = sc.SqlSchema.StringList.createValuesVector(b, offs);
      sc.SqlSchema.StringList.startStringList(b);
      sc.SqlSchema.StringList.addValues(b, vec);
      const off = sc.SqlSchema.StringList.endStringList(b);
      return { type: sc.SqlSchema.FilterValue.StringList, off };
    }
    if (isBoolArray(v)) {
      const vec = sc.SqlSchema.BoolList.createValuesVector(b, v);
      sc.SqlSchema.BoolList.startBoolList(b);
      sc.SqlSchema.BoolList.addValues(b, vec);
      const off = sc.SqlSchema.BoolList.endBoolList(b);
      return { type: sc.SqlSchema.FilterValue.BoolList, off };
    }
    if (isNumberArray(v)) {
      // If all integers, still prefer Float64List to avoid int64 range issues
      const vec = sc.SqlSchema.Float64List.createValuesVector(b, v);
      sc.SqlSchema.Float64List.startFloat64List(b);
      sc.SqlSchema.Float64List.addValues(b, vec);
      const off = sc.SqlSchema.Float64List.endFloat64List(b);
      return { type: sc.SqlSchema.FilterValue.Float64List, off };
    }
  }

  // fallback: stringify
  const s = b.createString(String(v));
  sc.SqlSchema.StringValue.startStringValue(b);
  sc.SqlSchema.StringValue.addValue(b, s);
  const off = sc.SqlSchema.StringValue.endStringValue(b);
  return { type: sc.SqlSchema.FilterValue.StringValue, off };
}

/** FB FilterValue -> JSON value */
export function decodeFilterValue(valType: number, get: <T>(o: T) => T | null): unknown {
  switch (valType) {
    case sc.SqlSchema.FilterValue.StringValue: {
      const o = new sc.SqlSchema.StringValue();
      const got = get(o);
      return got ? o.value() : null;
    }
    case sc.SqlSchema.FilterValue.NumberValue: {
      const o = new sc.SqlSchema.NumberValue();
      const got = get(o);
      return got ? o.value() : null;
    }
    case sc.SqlSchema.FilterValue.BoolValue: {
      const o = new sc.SqlSchema.BoolValue();
      const got = get(o);
      return got ? !!o.value() : null;
    }
    case sc.SqlSchema.FilterValue.Int64Value: {
      const o = new sc.SqlSchema.Int64Value();
      const got = get(o);
      return got ? Number(o.value()) : null;
    }
    case sc.SqlSchema.FilterValue.NullValue:
      return null;
    case sc.SqlSchema.FilterValue.TimestampValue: {
      const o = new sc.SqlSchema.TimestampValue();
      const got = get(o);
      return got ? Number(o.epoch()) : null;
    }
    case sc.SqlSchema.FilterValue.StringList: {
      const o = new sc.SqlSchema.StringList();
      const got = get(o);
      if (!got) return null;
      const arr: string[] = [];
      const n = o.valuesLength() ?? 0;
      for (let i = 0; i < n; i++) {
        const s = o.values(i);
        if (s != null) arr.push(s);
      }
      return arr;
    }
    case sc.SqlSchema.FilterValue.Int64List: {
      const o = new sc.SqlSchema.Int64List();
      const got = get(o);
      if (!got) return null;
      const arr: number[] = [];
      const n = o.valuesLength() ?? 0;
      for (let i = 0; i < n; i++) {
        const v = o.values(i);
        if (v != null) arr.push(Number(v));
      }
      return arr;
    }
    case sc.SqlSchema.FilterValue.Float64List: {
      const o = new sc.SqlSchema.Float64List();
      const got = get(o);
      if (!got) return null;
      const arr: number[] = [];
      const n = o.valuesLength() ?? 0;
      for (let i = 0; i < n; i++) {
        const v = o.values(i);
        if (v != null) arr.push(v);
      }
      return arr;
    }
    case sc.SqlSchema.FilterValue.BoolList: {
      const o = new sc.SqlSchema.BoolList();
      const got = get(o);
      if (!got) return null;
      const arr: boolean[] = [];
      const n = o.valuesLength() ?? 0;
      for (let i = 0; i < n; i++) {
        const v = o.values(i);
        if (v != null) arr.push(!!v);
      }
      return arr;
    }
    default:
      return null;
  }
}
-------- [ Separator ] ------

File Name: src/index.ts
Size: 128 B
Code:
export * from "./types.js";
export { buildRequestBuffer } from "./encode.js";
export { parseResponseBuffer } from "./decode.js";
-------- [ Separator ] ------

File Name: src/types.ts
Size: 6.55 KB
Code:
// === Public JSON types (exactly the toMap-style shapes you shared) ===

// Wrapper type: always explicit string
export enum SQLFilterWrapperType {
  or = "or",
  and = "and"
}

// NULL sort ordering
export enum NullsSortOrder {
  first = "first",
  last = "last",
  default_ = "default"
}

// Sorting spec
export interface DataSort {
  field: string;
  ascending: boolean;
}

export enum OrderSort {
  ASC_DEFAULT = "ASC_DEFAULT",
  ASC_NULLS_FIRST = "ASC_NULLS_FIRST",
  ASC_NULLS_LAST = "ASC_NULLS_LAST",
  DESC_DEFAULT = "DESC_DEFAULT",
  DESC_NULLS_FIRST = "DESC_NULLS_FIRST",
  DESC_NULLS_LAST = "DESC_NULLS_LAST"
}

export interface OrderKeySpec {
  field: string;
  sort: OrderSort;
}

// Filter types: NOTE — flatbuffers version supports a reduced subset.
// We keep your full enum for typing, but the encoder only maps those
// present in SqlSchema.BasicSqlDataFilterType.
export enum SQLDataFilterType {
  equals = "equals",
  notEquals = "notEquals",
  lessThan = "lessThan",
  lessThanOrEquals = "lessThanOrEquals",
  greaterThan = "greaterThan",
  greaterThanOrEquals = "greaterThanOrEquals",

  isNull = "isNull",
  isNotNull = "isNotNull",

  regex = "regex",
  notRegex = "notRegex",
  startsWith = "startsWith",
  endsWith = "endsWith",
  contains = "contains",
  notContains = "notContains",

  arrayContains = "arrayContains",
  arrayContainedBy = "arrayContainedBy",
  arrayOverlaps = "arrayOverlaps",
  arrayEquals = "arrayEquals",
  arrayNotEquals = "arrayNotEquals",
  arrayEmpty = "arrayEmpty",
  arrayNotEmpty = "arrayNotEmpty",
  arrayLength = "arrayLength",

  jsonContains = "jsonContains",
  jsonContainedBy = "jsonContainedBy",
  jsonHasKey = "jsonHasKey",
  jsonHasAnyKey = "jsonHasAnyKey",
  jsonHasAllKeys = "jsonHasAllKeys",
  jsonGetField = "jsonGetField",
  jsonGetFieldAsText = "jsonGetFieldAsText",

  between = "between",
  notBetween = "notBetween",
  rangeContains = "rangeContains",
  rangeContainedBy = "rangeContainedBy",

  in_ = "in",
  notIn = "notIn",

  // many more in your model — omitted since not supported by FB spec
}

export interface BaseSqlDataFilter { }

export interface SqlFilterModifier {
  distinct?: boolean;
  caseInSensitive: boolean;
  nullsOrder: NullsSortOrder;
}

export interface SqlDataFilter extends BaseSqlDataFilter {
  fieldName: string;
  value: unknown; // can be scalar | array for between/in/etc.
  filterType: SQLDataFilterType;
  modifier?: SqlFilterModifier;
}

export interface SqlDataFilterWrapper extends BaseSqlDataFilter {
  filterWrapperType: SQLFilterWrapperType;
  filters: BaseSqlDataFilter[];
}

// ---- Table definition JSON (from your models/table_definition.ts) ----

export enum ColumnConstraint {
  primaryKey = "primaryKey",
  unique = "unique",
  notNull = "notNull",
  check = "check",
  default_ = "default_",
  indexed = "indexed",
  exclusion = "exclusion",
  generated = "generated",
  identity = "identity",
  references = "references",
  noInherit = "noInherit",
  nullsNotDistinct = "nullsNotDistinct"
}

export enum SQLDataType {
  text = "text",
  varchar = "varchar",
  char = "char",
  varcharArray = "varcharArray",
  textArray = "textArray",
  charArray = "charArray",
  integer = "integer",
  bigInt = "bigInt",
  smallInt = "smallInt",
  decimal = "decimal",
  numeric = "numeric",
  real = "real",
  doublePrecision = "doublePrecision",
  serial = "serial",
  bigSerial = "bigSerial",
  smallSerial = "smallSerial",
  money = "money",
  date = "date",
  time = "time",
  timestamp = "timestamp",
  timestamptz = "timestamptz",
  interval = "interval",
  timetz = "timetz",
  boolean = "boolean",
  bytea = "bytea",
  json = "json",
  jsonb = "jsonb",
  jsonArray = "jsonArray",
  jsonbArray = "jsonbArray",
  uuid = "uuid",
  xml = "xml",
  array = "array",
  custom = "custom"
}

export interface TableColumnJson {
  name: string;
  dataType: SQLDataType;
  isNullable: boolean;
  constraints: ColumnConstraint[];
  customOptions?: Record<string, string | number | boolean>;
}

export interface TableDefinitionJson {
  name: string;
  columns: TableColumnJson[];
  comment?: string;
  tableOptions?: Record<string, string | number | boolean>;
}

// ---- Request JSONs (exact toMap outputs) ----

export interface BaseDbJson {
  tableName: string;
  companyId: string;
}

export interface GetDataJson extends BaseDbJson {
  dataSort?: DataSort;
  filters?: BaseSqlDataFilter[];
  limit?: number;
  offset?: number;
  orderKeys?: OrderKeySpec[];
  cursor?: Record<string, unknown>;
  strictAfter?: boolean;
}

export interface GetSingleJson extends BaseDbJson {
  primaryKeyColumn: string;
  primaryId: string;
}

export interface AddSingleJson extends BaseDbJson {
  primaryKeyColumn: string;
  data: Record<string, unknown>;
}

export interface UpdateSingleJson extends BaseDbJson {
  primaryKeyColumn: string;
  primaryId: string;
  updates: Record<string, unknown>;
}

export interface DeleteRowJson extends BaseDbJson {
  primaryKeyColumn: string;
  primaryId: string;
}

export interface CreateTableJson {
  companyId: string;
  definition: TableDefinitionJson;
}

export interface TableExistsJson extends BaseDbJson { }

export interface RunAggregationJson extends BaseDbJson {
  sumFields?: string[];
  averageFields?: string[];
  minimumFields?: string[];
  maximumFields?: string[];
  countEnabled?: boolean;
  filters?: BaseSqlDataFilter[];
}

// ---- Envelope for requests ----

export type RequestPayloadJson =
  | { method: "GET_DATA"; payload: GetDataJson }
  | { method: "GET_SINGLE"; payload: GetSingleJson }
  | { method: "ADD_SINGLE"; payload: AddSingleJson }
  | { method: "UPDATE_SINGLE"; payload: UpdateSingleJson }
  | { method: "DELETE_ROW"; payload: DeleteRowJson }
  | { method: "CREATE_TABLE"; payload: CreateTableJson }
  | { method: "TABLE_EXISTS"; payload: TableExistsJson }
  | { method: "RUN_AGGREGATION"; payload: RunAggregationJson };

export type RequestEnvelopeJson = {
  correlationId: string;
  replyTopic: string;
} & RequestPayloadJson;

// ---- Responses (decoded JSON) ----

export type RpcErrorCode = "NONE" | "BAD_REQUEST" | "INTERNAL";

export type RpcResponseJson =
  | { type: "RowsJson"; rows: string[] }
  | { type: "RowJson"; row: string }
  | { type: "BoolRes"; value: boolean }
  | { type: "AggRes"; agg: { count?: number; sumValues?: Record<string, number>; avgValues?: Record<string, number>; minimumValues?: Record<string, number>; maximumValues?: Record<string, number> } }
  | { type: "RowsWithCursor"; rows: string[]; cursor: Record<string, unknown> };

export interface ResponseEnvelopeJson {
  correlationId: string;
  ok: boolean;
  errorCode: RpcErrorCode;
  errorMessage?: string | null;
  data?: RpcResponseJson | undefined;
}
-------- [ Separator ] ------
